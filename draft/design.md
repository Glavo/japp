# 设计方案（草稿）

目的：设计一个新的格式 (`japp`)，允许将一组模块化或者非模块化的 JAR 捆绑进同一个文件中，同时支持在该文件中描述对 Java 版本的需求，启动时能够自动选择正确的 Java 版本。

## 架构

本项目计划有如下几个子模块：

* `packer`: 打包器模块，用于生成 japp 文件 (用 Java 实现)。
* `launcher`: 启动器模块，用于启动 japp 格式的程序 (前期原型仅用 Java 实现，后期同时提供一个由 Rust 重新实现的版本)。
* `boot-launcher`: 引导模块，用于在 Java 程序中支持直接从 japp 文件中加载类 (用 Java 实现)。
* `Gradle`/`Maven` Plugin: 用于直接在构建工具中打包 japp。

## 文件格式

具体格式设计中，这里是一些想法；

* 文件 magic number 和元数据放置在文件最后，这样我们可以默认在文件头部拼接这样一段 shell：
    
    ```bash
    #!/usr/bin/env japp
    ```
  
    我们可以使用该文件头让程序能够直接在 Unix-Like 的系统上以 `./myapp.japp` 的方式运行，而对于 Windows 则注册文件的打开方式，允许双击打开。
    文件头可以灵活更改，之后可以在其中实现更多逻辑，比如在发现用户没有安装 japp 启动器时给用户更详细的提示与引导。

* 我们应该使用类似 JImage 的方式，使用一个共享字符串池存储类名信息，加载时再通过 `boot-launcher` 重新复原类。
* 对于共享字符串池，我们可以运用某种压缩方法进行压缩处理。(也许可以采用 LZ4 或者 zstd，并使用 Java 标准库和常用类的名称生成一个预训练字典)
* 文件中应该提供元数据描述程序兼容的 Java 版本 (以及其他信息？)，在执行时启动器可以根据此信息自动选择 Java。
* 文件中可以提供一组必要的 JVM 选项 (比如 `--add-opens` 等)，以及一些条件应用的 JVM 选项。
* 某些 JAR 也许对 JAR 文件本身有一定要求，也许应该提供一个将 JAR 整体包含进 japp 文件中的方式。
* 是否需要保留 CLASS 文件元信息 (创建时间/修改时间等)?

文件结构草稿：

* 用户文件头 (通常为 Shebang, japp 应忽略)
* 类路径
* TODO
* TODO
* 文件索引池
* boot-launcher 元数据
* launcher 元数据 (包含 Java 版本、JVM 参数等信息)
* 文件尾部标记 (48 字节):
  * 4 字节 Magic Number `JAPP`
  * 4 字节版本号
    * 2 字节主版本号 (不向后兼容)
    * 2 字节副版本号 (向后兼容)
  * 8 字节 flags
  * 8 字节文件大小
  * 8 字节 launcher 元数据 Offset
  * 8 字节 boot-launcher 元数据 Offset
  * 8 字节预留

元数据和文件尾由 launcher 解析，其余部分由 boot-launcher 解析。 

以上结构尚未完成设计。为了更快速的实现一个可工作的原型，以下是临时使用的简化设计:

* 用户文件头 (通常为 Shebang, japp 应忽略)
* 文件数据池
* 文件元数据 (变长, 使用 GZIP 压缩的 JSON 格式)
* 文件尾部标记 (48 字节):
  * 4 字节 Magic Number `JAPP`
  * 4 字节版本号
    * 2 字节主版本号 (不向后兼容)
    * 2 字节副版本号 (向后兼容)
  * 8 字节 flags
  * 8 字节文件大小
  * 8 字节元数据 Offset
  * 16 字节预留

该简化设计主要目的是简化实现，解析效率和程序体积不是前期重点。在实验过程中 JAPP 会逐步向完整格式方向发展，逐步解决这些问题。

实验阶段文件主版本号为 0xffff，每次更新格式只迭代次要版本号，每次更新都可能造成不兼容。

TODO

## 启动器

japp 启动器应该管理一组 Java，每次使用时解析 japp 文件的元数据，查找匹配的 Java 以及解析应使用的 JVM 选项启动程序。

当启动器检测到环境不满足程序元数据中描述的条件时，应给出用户友好的提示。
